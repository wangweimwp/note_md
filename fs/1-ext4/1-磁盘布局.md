## 1 磁盘布局
![](./image/1.png)
### 2 sparse_super
![](./image/2.png)
#### 2.1 sparse_super特性
效果为：超级块和GDT备份只出现在3，5，7的幂
按照226组块，如果开启该特性，超级块和GDT只会出现在：组块0(主超级块)，1，3，5，7，9，21，27，49，81，125组块中，除主超级块其余皆为备份
![](./image/3.png)
### 3 Block Group
Block Group Descriptor
![](./image/4.png)

### 4 数据块位图和inode位图
数据块位图跟踪块组中数据块使用情况。Inode位图跟踪块组中Inode使用情况。每个位图一个数据块，每一位用0或1表示一个块组中数据块或inode表中inode的使用情况

Blockbitmap包含了超级块等使用情况，即使用了就是1，(1288+108+7=1111)
下图为定位到的BB的块然后dump出来，查看一下。
![](./image/5.png)
与上图对照，是一致的，free block从1111开始 即使用的是0-1110
![](./image/6.png)
### 5 Inode表
Inode表中存储的就是inode的信息。Inode的大小是在超级块中的s_inode_size字段决定。

![](./image/7.png)
![](./image/8.png)

**<font color="yellow">inode编号从1开始，对于inode为17的文件，偏移位置为(17-1) * s_inode_size</font>**



i_extra_isize：超出128部分的长度，包括该字段 现阶段该值一般都为32 也就是说ext4的inode实际使用的长度为128+32=160，总大小256
如果开启inline_data特性，未使用的部分会填充数据
```c
struct ext4_inode {
    /* File mode */
	#define EXT4_S_IXOTH 0x1  //(Others may execute)
	#define EXT4_S_IWOTH 0x2  //(Others may write)
	#define EXT4_S_IROTH 0x4  // Others may read)
	
	#define EXT4_S_IXGRP 0x8   //(Group members may execute)
	#define EXT4_S_IWGRP 0x10  //(Group members may write)
	#define EXT4_S_IRGRP 0x20  //(Group members may read)
	
	#define EXT4_S_IXUSR 0x40   //(Owner may execute)
	#define EXT4_S_IWUSR 0x80   //(Owner may write)
	#define EXT4_S_IRUSR 0x100  //(Owner may read)
	
	#define EXT4_S_ISVTX 0x200  //(Sticky bit)
	#define EXT4_S_ISGID 0x400  //(Set GID)
	#define EXT4_S_ISUID 0x800  //(Set UID)
	
	/* These are mutually-exclusive file types: */
	#define EXT4_S_IFIFO 0x1000   //(FIFO)
	#define EXT4_S_IFCHR 0x2000   //(Character device)
	#define EXT4_S_IFDIR 0x4000   //(Directory)
	#define EXT4_S_IFBLK 0x6000   //(Block device)
	#define EXT4_S_IFREG 0x8000   //(Regular file)
	#define EXT4_S_IFLNK 0xA000   //(Symbolic link)
	#define EXT4_S_IFSOCK 0xC000  //(Socket)
    __le16 i_mode;        /* File mode 文件的类型和权限*/
    
    __le16 i_uid;         /* Low 16 bits of Owner Uid */
    __le32 i_size_lo;     /* Size in bytes 该inode对应的文件的大小*/
    __le32 i_atime;       /* Access time */
    __le32 i_ctime;       /* Inode Change time */
    __le32 i_mtime;       /* Modification time */
    __le32 i_dtime;       /* Deletion Time */
    __le16 i_gid;         /* Low 16 bits of Group Id */
    __le16 i_links_count; /* Links count 硬连接数 */
    __le32 i_blocks_lo;   /* Blocks count */

    /* 看上面宏定义规定的flag状态 */
    __le32 i_flags; /* File flags */
    union {
        struct {
            __le32 l_i_version;
        } linux1;
        struct {
            __u32 h_i_translator;
        } hurd1;
        struct {
            __u32 m_i_reserved1;
        } masix1;
    } osd1;                        /* OS dependent 1 */
    __le32 i_block[EXT4_N_BLOCKS]; /* Pointers to blocks 后面祥讲*/
    __le32 i_generation;           /* File version (for NFS) */
    __le32 i_file_acl_lo;          /* File ACL */
    __le32 i_size_high;
    __le32 i_obso_faddr; /* Obsoleted fragment address */
    union {
        struct {
            __le16 l_i_blocks_high; /* were l_i_reserved1 */
            __le16 l_i_file_acl_high;
            __le16 l_i_uid_high;    /* these 2 fields */
            __le16 l_i_gid_high;    /* were reserved2[0] */
            __le16 l_i_checksum_lo; /* crc32c(uuid+inum+inode) LE */
            __le16 l_i_reserved;
        } linux2;
        struct {
            __le16 h_i_reserved1; /* Obsoleted fragment number/size which are removed in ext4 */
            __u16 h_i_mode_high;
            __u16 h_i_uid_high;
            __u16 h_i_gid_high;
            __u32 h_i_author;
        } hurd2;
        struct {
            __le16 h_i_reserved1; /* Obsoleted fragment number/size which are removed in ext4 */
            __le16 m_i_file_acl_high;
            __u32 m_i_reserved2[2];
        } masix2;
    } osd2; /* OS dependent 2 */
    __le16 i_extra_isize;
    __le16 i_checksum_hi;  /* crc32c(uuid+inum+inode) BE */
    __le32 i_ctime_extra;  /* extra Change time      (nsec << 2 | epoch) */
    __le32 i_mtime_extra;  /* extra Modification time(nsec << 2 | epoch) */
    __le32 i_atime_extra;  /* extra Access time      (nsec << 2 | epoch) */
    __le32 i_crtime;       /* File Creation time */
    __le32 i_crtime_extra; /* extra FileCreationtime (nsec << 2 | epoch) */
    __le32 i_version_hi;   /* high 32 bits for 64-bit version */
    __le32 i_projid;       /* Project ID */
};

```
第1-11个inode有特殊用途
```text
    Inode号    用途
    0      不存在0号inode
    1      损坏数据块链表
    2      根目录
    3      User quota. 用户quota索引
    4      Group quota. 组quota索引
    5      Boot loader
    6      Undelete directory. 未删除的目录
    7      预留的块组描述符inode. (用于调整inode数目)
    8      日志inode
    9      The "exclude" inode, for snapshots(?)
    10     Replica inode, used for some non-upstream feature?
    11     第一个非预留的inode，通常是lost+found目录

```

#### 5.1 数据索引
Inode中有个 数组__le32 i_block[15]，该数组中，前12个是直接索引，后面三个分别是一级索引、二级索引和三级索引。这种方式不仅实现起来较为复杂，而且在面对大文件的时候效率较为低下，且会浪费很多的间接块以存储映射关系
![](./image/9.png)
extent特性为ext4新增特性, 开启该特性后：在inode节点中的60byte存放1个Header和4个Entry
Inode Table结构体上存放着4个ext4_extent，每个ext4_extent结构体对应1个BG(1个Block的Bit总共有4096 * 8)的32768个Block，32768 * 4KB=128MB。4个ext4_extent对应4个BG，总共512MB。除去元文件信息，剩余的数据信息480MB左右。
![](./image/10.png)
超过480MB的文件则会启用树形结构，Inode Table上则存放ext4_extent_idx，其指向Data Block。Data Block上记录ext4_extent信息，一个块占用4KB，除去12byte的Header其他全都用来存储ext4_extent，共可以存储：（4096 - 12）/ 12 = 340 个ext4_exten，算下来可以存储 340 * 128M = 42.5G,4个Data Block则是170GB。添加一级索引就可以描述170GB文件，一般情况都够用。
![](./image/11.png)

